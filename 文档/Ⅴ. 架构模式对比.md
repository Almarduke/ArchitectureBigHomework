## Ⅴ. 架构模式对比

### 5.1 综述

### 5.2 性能

| 微服务架构                                                   | CS架构                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 低并发情况下，服务间需要通信，会受到网络延迟，消息传递等影响，降低性能 | 低并发情况下，通过共享内存访问进行通信，性能更好             |
| 高并发情况下，可以为单个服务增加计算资源，其他服务的性能不会受到影响，性能更好 | 高并发情况下，单台服务器的存储能力和处理能力会成为约束性能的瓶颈，而且单个功能会消耗更多的计算资源，降低其他功能的性能 |



### 5.3 可用性

| 微服务架构                                                   | CS架构                                     |
| ------------------------------------------------------------ | ------------------------------------------ |
| 分离的服务有更好的容错性，正常情况下一台服务器宕机不会使整个系统崩溃，有更好的可用性 | 错误会对整个应用的稳定产生影响，可用性更低 |



### 5.4 安全性

| 微服务架构 | CS架构 |
| ---------- | ------ |
|            |        |
|            |        |
|            |        |



### 5.5 成本

| 微服务架构                                                   | CS架构                                           |
| ------------------------------------------------------------ | ------------------------------------------------ |
| 结构复杂，开发成本更高                                       | 结构简单，复杂度低，开发的成本更低               |
| 服务之间相互分离，容易对某个服务进行修改和重新部署，维护成本较低 | 模块之间耦合度更高，维护成本更高                 |
| 低并发量需要更多的计算资源，硬件成本更高                     | 低并发量需要更少的计算资源，硬件成本更低         |
| 高并发量下，可以对单个服务进行伸缩，硬件成本更低             | 高并发量下，需要对整个应用进行伸缩，硬件成本更高 |



### 5.6 可测试性

| 微服务架构                 | CS架构 |
| -------------------------- | ------ |
| 测试前需要确认依赖的服务，降低了可测试性 | 将应用整体打包，更加容易测试 |

### 5.7 结论

